.\" Automatically generated by Pod::Man 2.23 (Pod::Simple 3.14)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.ie \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.el \{\
.    de IX
..
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "enum 3pm"
.TH enum 3pm "1999-05-27" "perl v5.12.4" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
enum \- C style enumerated types and bitmask flags in Perl
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 2
\&  use enum qw(Sun Mon Tue Wed Thu Fri Sat);
\&  # Sun == 0, Mon == 1, etc
\&
\&  use enum qw(Forty=40 FortyOne Five=5 Six Seven);
\&  # Yes, you can change the start indexs at any time as in C
\&
\&  use enum qw(:Prefix_ One Two Three);
\&  ## Creates Prefix_One, Prefix_Two, Prefix_Three
\&
\&  use enum qw(:Letters_ A..Z);
\&  ## Creates Letters_A, Letters_B, Letters_C, ...
\&
\&  use enum qw(
\&      :Months_=0 Jan Feb Mar Apr May Jun Jul Aug Sep Oct Nov Dec
\&      :Days_=0   Sun Mon Tue Wed Thu Fri Sat
\&      :Letters_=20 A..Z
\&  );
\&  ## Prefixes can be changed mid list and can have index changes too
\&
\&  use enum qw(BITMASK:LOCK_ SH EX NB UN);
\&  ## Creates bitmask constants for LOCK_SH == 1, LOCK_EX == 2,
\&  ## LOCK_NB == 4, and LOCK_UN == 8.
\&  ## NOTE: This example is only valid on FreeBSD\-2.2.5 however, so don\*(Aqt
\&  ## actually do this.  Import from Fnctl instead.
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
Defines a set of symbolic constants with ordered numeric values ala \fBC\fR \fBenum\fR types.
.PP
Now capable of creating creating ordered bitmask constants as well.  See the \fB\s-1BITMASKS\s0\fR
section for details.
.PP
What are they good for?  Typical uses would be for giving mnemonic names to indexes of
arrays.  Such arrays might be a list of months, days, or a return value index from
a function such as \fIlocaltime()\fR:
.PP
.Vb 5
\&  use enum qw(
\&      :Months_=0 Jan Feb Mar Apr May Jun Jul Aug Sep Oct Nov Dec
\&      :Days_=0   Sun Mon Tue Wed Thu Fri Sat
\&      :LC_=0     Sec Min Hour MDay Mon Year WDay YDay Isdst
\&  );
\&
\&  if ((localtime)[LC_Mon] == Months_Jan) {
\&      print "It\*(Aqs January!\en";
\&  }
\&  if ((localtime)[LC_WDay] == Days_Fri) {
\&      print "It\*(Aqs Friday!\en";
\&  }
.Ve
.PP
This not only reads easier, but can also be typo-checked at compile time when
run under \fBuse strict\fR.  That is, if you misspell \fBDays_Fri\fR as \fBDays_Fry\fR,
you'll generate a compile error.
.SH "BITMASKS, bitwise operations, and bitmask option values"
.IX Header "BITMASKS, bitwise operations, and bitmask option values"
The \fB\s-1BITMASK\s0\fR option allows the easy creation of bitmask constants such as
functions like \fIflock()\fR and \fIsysopen()\fR use.  These are also very useful for your
own code as they allow you to efficiently store many true/false options within
a single integer.
.PP
.Vb 1
\&    use enum qw(BITMASK: MY_ FOO BAR CAT DOG);
\&
\&    my $foo = 0;
\&    $foo |= MY_FOO;
\&    $foo |= MY_DOG;
\&    
\&    if ($foo & MY_DOG) {
\&        print "foo has the MY_DOG option set\en";
\&    }
\&    if ($foo & (MY_BAR | MY_DOG)) {
\&        print "foo has either the MY_BAR or MY_DOG option set\en"
\&    }
\&
\&    $foo ^= MY_DOG;  ## Turn MY_DOG option off (set its bit to false)
.Ve
.PP
When using bitmasks, remember that you must use the bitwise operators, \fB|\fR, \fB&\fR, \fB^\fR,
and \fB~\fR.  If you try to do an operation like \f(CW\*(C`$foo += MY_DOG;\*(C'\fR and the \fB\s-1MY_DOG\s0\fR bit
has already been set, you'll end up setting other bits you probably didn't want to set.
You'll find the documentation for these operators in the \fBperlop\fR manpage.
.PP
You can set a starting index for bitmasks just as you can for normal \fBenum\fR values,
but if the given index isn't a power of 2 it won't resolve to a single bit and therefor
will generate a compile error.  Because of this, whenever you set the \fB\s-1BITFIELD:\s0\fR
directive, the index is automatically set to 1.  If you wish to go back to normal \fBenum\fR
mode, use the \fB\s-1ENUM:\s0\fR directive.  Similarly to the \fB\s-1BITFIELD\s0\fR directive, the \fB\s-1ENUM:\s0\fR
directive resets the index to 0.  Here's an example:
.PP
.Vb 6
\&  use enum qw(
\&      BITMASK:BITS_ FOO BAR CAT DOG
\&      ENUM: FALSE TRUE
\&      ENUM: NO YES
\&      BITMASK: ONE TWO FOUR EIGHT SIX_TEEN
\&  );
.Ve
.PP
In this case, \fB\s-1BITS_FOO\s0, \s-1BITS_BAR\s0, \s-1BITS_CAT\s0, and \s-1BITS_DOG\s0\fR equal 1, 2, 4 and
8 respectively.  \fB\s-1FALSE\s0 and \s-1TRUE\s0\fR equal 0 and 1.  \fB\s-1NO\s0 and \s-1YES\s0\fR also equal
0 and 1.  And \fB\s-1ONE\s0, \s-1TWO\s0, \s-1FOUR\s0, \s-1EIGHT\s0, and \s-1SIX_TEEN\s0\fR equal, you guessed it, 1,
2, 4, 8, and 16.
.SH "BUGS"
.IX Header "BUGS"
Enum names can not be the same as method, function, or constant names.  This
is probably a Good Thing[tm].
.PP
No way (that I know of) to cause compile time errors when one of these enum names get
redefined.  \s-1IMHO\s0, there is absolutely no time when redefining a sub is a Good Thing[tm],
and should be taken out of the language, or at least have a pragma that can cause it
to be a compile time error.
.PP
Enumerated types are package scoped just like constants, not block scoped as some
other pragma modules are.
.PP
It supports A..Z nonsense.  Can anyone give me a Real World[tm] reason why anyone would
ever use this feature...?
.SH "HISTORY"
.IX Header "HISTORY"
.Vb 2
\&  $Log: enum.pm,v $
\&  Revision 1.16  1999/05/27 16:00:35  byron
\&
\&
\&  Fixed bug that caused bitwise operators to treat enum types as strings
\&  instead of numbers.
\&
\&  Revision 1.15  1999/05/27 15:51:27  byron
\&
\&
\&  Add support for negative values.
\&
\&  Added stricter hex value checks.
\&
\&  Revision 1.14  1999/05/13 15:58:18  byron
\&
\&
\&  Fixed bug in hex index code that broke on 0xA.
\&
\&  Revision 1.13  1999/05/13 10:52:30  byron
\&
\&
\&  Fixed auto\-index bugs in new non\-decimal numeric support.
\&
\&  Revision 1.12  1999/05/13 10:00:45  byron
\&
\&
\&  Added support for non\-decimal numeric representations ala 0x123, 0644, and
\&  123_456.
\&
\&  First version committed to CVS.
\&
\&
\&  Revision 1.11  1998/07/18 17:53:05  byron
\&    \-Added BITMASK and ENUM directives.
\&    \-Revamped documentation.
\&
\&  Revision 1.10  1998/06/12 20:12:50  byron
\&    \-Removed test code
\&    \-Released to CPAN
\&
\&  Revision 1.9  1998/06/12 00:21:00  byron
\&    \-Fixed \-w warning when a null tag is used
\&
\&  Revision 1.8  1998/06/11 23:04:53  byron
\&    \-Fixed documentation bugs
\&    \-Moved A..Z case to last as it\*(Aqs not going to be used
\&     as much as the other cases.
\&
\&  Revision 1.7  1998/06/10 12:25:04  byron
\&    \-Changed interface to match original design by Tom Phoenix
\&     as implemented in an early version of enum.pm by Benjamin Holzman.
\&    \-Changed tag syntax to not require the \*(AqPREFIX\*(Aq string of Tom\*(Aqs
\&     interface.
\&    \-Allow multiple prefix tags to be used at any point.
\&    \-Allowed index value changes from tags.
\&
\&  Revision 1.6  1998/06/10 03:37:57  byron
\&    \-Fixed superfulous \-w warning
\&
\&  Revision 1.4  1998/06/10 01:07:03  byron
\&    \-Changed behaver to closer resemble C enum types
\&    \-Changed docs to match new behaver
.Ve
.SH "AUTHOR"
.IX Header "AUTHOR"
Zenin <zenin@archive.rhps.org>
.PP
aka Byron Brummer <byron@omix.com>.
.PP
Based off of the \fBconstant\fR module by Tom Phoenix.
.PP
Original implementation of an interface of Tom Phoenix's
design by Benjamin Holzman, for which we borrow the basic
parse algorithm layout.
.SH "COPYRIGHT"
.IX Header "COPYRIGHT"
Copyright 1998 (c) Byron Brummer.
Copyright 1998 (c) \s-1OMIX\s0, Inc.
.PP
Permission to use, modify, and redistribute this module granted under
the same terms as \fBPerl\fR.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
\&\fIconstant\fR\|(3), \fIperl\fR\|(1).
